---
lab:
  az204Title: 'Lab 02: Implement task processing logic by using Azure Functions'
  az020Title: 'Lab 02: Implement task processing logic by using Azure Functions'
  az204Module: 'Module 02: Implement Azure Functions'
  az020Module: 'Module 02: Implement Azure Functions'
---

# <a name="lab-02-implement-task-processing-logic-by-using-azure-functions"></a>랩 02: Azure Functions를 사용한 작업 처리 논리 구현

## <a name="microsoft-azure-user-interface"></a>Microsoft Azure 사용자 인터페이스

Given the dynamic nature of Microsoft cloud tools, you might experience Azure UI changes that occur after the development of this training content. As a result, the lab instructions and lab steps might not align correctly.

Microsoft updates this training course when the community alerts us to needed changes. However, cloud updates occur frequently, so you might encounter UI changes before this training content updates. <bpt id="p1">**</bpt>If this occurs, adapt to the changes, and then work through them in the labs as needed.<ept id="p1">**</ept>

## <a name="instructions"></a>Instructions

### <a name="before-you-start"></a>시작하기 전에

#### <a name="sign-in-to-the-lab-environment"></a>랩 환경에 로그인

다음 자격 증명을 사용하여 Windows 10 VM(가상 머신)에 로그인합니다.

- 사용자 이름: **Admin**
- 암호: **Pa55w.rd**

> **참고**: 강사가 가상 랩 환경 연결에 대한 지침을 제공합니다.

#### <a name="review-the-installed-applications"></a>설치된 애플리케이션 검토

Find the taskbar on your Windows 10 desktop. The taskbar contains the icons for the applications that you'll use in this lab, including:

- Microsoft Edge
- 파일 탐색기
- Windows 터미널
- Visual Studio Code

## <a name="architecture-diagram"></a>아키텍처 다이어그램

![Azure Functions를 사용하여 작업 처리 논리를 구현하는 사용자를 보여 주는 아키텍처 다이어그램.](./media/Lab02-Diagram.png)

### <a name="exercise-1-create-azure-resources"></a>연습 1: Azure 리소스 만들기

#### <a name="task-1-open-the-azure-portal"></a>작업 1: Azure Portal 열기

1. 작업 표시줄에서 **Microsoft Edge** 아이콘을 선택합니다.
1. 브라우저 창에서 Azure Portal(<https://portal.azure.com>)로 이동한 다음, 이 랩에 사용할 계정으로 로그인합니다.

    > Microsoft 클라우드 도구의 동적 특성을 고려할 때 이 교육 콘텐츠를 개발한 후 발생하는 Azure UI 변경이 발생할 수 있습니다.

#### <a name="task-2-create-an-azure-storage-account"></a>작업 2: Azure Storage 계정 만들기

1. Azure Portal에서 **리소스, 서비스 및 문서 검색** 텍스트 상자를 사용하여 **스토리지 계정**을 검색한 다음, 결과 목록에서 **스토리지 계정**을 선택합니다.

1.  **스토리지 계정** 블레이드에서 **+ 만들기**를 선택합니다.

1. **스토리지 계정 만들기** 블레이드의 **기본 사항** 탭에서 다음 작업을 수행하고 **검토 + 만들기**를 선택합니다.

    | 설정 | 작업 |
    | -- | -- |
    | **구독** 드롭다운 목록 | 기본값을 유지합니다. |
    | **리소스 그룹** 섹션 | **새로 만들기**를 선택하고 **Serverless**를 입력한 다음, **확인**을 선택합니다. |
    | **스토리지 계정 이름** 텍스트 상자 | **funcstor** _[사용자 이름]_ 을 입력합니다. |
    | **지역** 드롭다운 목록 | **(미국) 미국 동부**를 선택합니다. |
    | **성능** 섹션 | **표준** 옵션을 선택합니다. |
    | **중복도** 드롭다운 목록 | **LRS(로컬 중복 스토리지)** 를 선택합니다. |

    다음 스크린샷은 **스토리지 계정 만들기** 창에 구성된 설정을 보여 줍니다.

    ![스토리지 계정 만들기 창에 구성된 설정이 표시된 스크린샷](./media/l02_create_a_storage_account.png)

1. **검토 + 만들기** 탭에서 이전 단계에서 선택한 옵션을 검토합니다.

1. 지정된 구성을 사용하여 스토리지 계정을 만들려면 **만들기**를 선택합니다.

    > **참고**: 이 랩을 계속 진행하기 전에 만들기 작업이 완료될 때까지 기다립니다.

1. **개요** 블레이드에서 **리소스로 이동** 단추를 선택하여 새로 만든 스토리지 계정의 블레이드로 이동합니다.

1.  **스토리지 계정** 블레이드의 **보안 + 네트워킹** 섹션에서**액세스 키**를 선택합니다.

1.  **액세스 키** 블레이드에서 **키 표시**를 선택합니다.

1. 키 중 하나를 검토한 다음, **연결 문자열** 상자 중 하나의 값을 클립보드에 복사합니다.

     > 따라서 랩 지침 및 랩 단계가 올바르게 정렬되지 않을 수 있습니다.

1. Open Notepad, and then paste the copied connection string value to Notepad. You'll use this value later in this lab.

#### <a name="task-3-create-a-function-app"></a>작업 3: 함수 앱 만들기

1. Azure Portal의 탐색 창에서 **리소스 만들기** 링크를 선택합니다.

1. **리소스 만들기** 창의 **검색 서비스 및 마켓플레이스** 텍스트 상자에 **함수**를 입력한 다음, Enter 키를 선택합니다.

1. **마켓플레이스** 검색 결과 창에서 **함수 앱** 결과를 선택합니다.

1. **함수 앱** 블레이드에서 **만들기**를 선택합니다.

1. **함수 앱 만들기** 창의 **기본 사항** 탭에서 다음 작업을 수행하고 **다음: 호스팅**을 선택합니다.

    | 설정 | 작업 |
    | -- | -- |
    | **구독** 드롭다운 목록 | 기본값을 유지합니다. |
    | **리소스 그룹** 섹션 | **서버리스**를 선택합니다. |
    | **함수 앱 이름** 텍스트 상자 | **funclogic** _[사용자 이름]_ 을 입력합니다. |
    | **게시** 섹션 | **코드** 선택 |
    | **런타임 스택** 드롭다운 목록 | **.NET**을 선택합니다. |
    | **버전** 드롭다운 목록 | **6**을 선택합니다. |
    | **지역** 드롭다운 목록 | **미국 동부** 지역을 선택합니다. |
    | **운영 체제** 옵션 | **Linux**를 선택합니다. |
    | **계획 유형** 드롭다운 목록 | **사용량(서버리스)** 을 선택합니다. |

    다음 스크린샷은 **함수 앱 만들기** 창에 구성된 설정을 보여 줍니다.

    ![함수 앱 만들기 창에 구성된 설정이 표시된 스크린샷](./media/l02_create_a_function_app.png)

1. **호스팅** 탭에서 다음 작업을 수행하고 **검토 + 만들기**를 선택합니다.

    | 설정 | 작업 |
    | -- | -- |
    | **스토리지 계정** 드롭다운 목록 | **funcstor** _[사용자 이름]_ 스토리지 계정을 선택합니다. |

1. **검토 + 만들기** 탭에서 이전 단계에서 선택한 옵션을 검토합니다.

1. 지정된 구성을 사용하여 함수 앱을 만들려면 **만들기**를 선택합니다.

    > **참고**: 이 랩을 진행하기 전에 만들기 작업이 완료될 때까지 기다립니다.

#### <a name="review"></a>검토

이 연습에서는 이 랩에서 사용할 모든 리소스를 만들었습니다.

### <a name="exercise-2-configure-a-local-azure-functions-project"></a>연습 2: 로컬 Azure Functions 프로젝트 구성

#### <a name="task-1-initialize-a-function-project"></a>작업 1: 함수 프로젝트 초기화

1. 작업 표시줄에서 **Windows 터미널** 아이콘을 선택합니다.

1. 다음 명령을 실행하여 현재 디렉터리를 **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** 빈 디렉터리로 변경합니다.

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

    > **참고**: Windows 탐색기에서 **F:\\Allfiles\\Labs\\02\\Starter\\func\\.gitignore** 파일에서 **읽기 전용** 특성을 제거합니다.

1. 다음 명령을 실행하여 **Azure Functions Core Tools**를 사용하여 **dotnet** 런타임을 통해 현재 디렉터리에 새 로컬 Azure Functions 프로젝트를 만듭니다.

    ```powershell
    func init --worker-runtime dotnet --force
    ```

    > **참고**: 설명서의 내용을 검토하여 **Azure Functions Core Tools**를 사용한 [새 프로젝트 만들기][azure-functions-core-tools-new-project] 방법을 파악할 수 있습니다.
    
1. **Windows 터미널** 애플리케이션을 엽니다.

#### <a name="task-2-configure-a-connection-string"></a>작업 2: 연결 문자열 구성

1. **시작** 화면에서 **Visual Studio Code** 타일을 선택합니다.
1. **파일** 메뉴에서 **폴더 열기**를 선택합니다.
1. 열리는 **파일 탐색기** 창에서 **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func**을 찾아본 후, **폴더 선택**을 선택합니다.
1. **Visual Studio Code** 창의 **탐색기** 창에서 **local.settings.json** 파일을 엽니다.
1. **AzureWebJobsStorage** 설정의 현재 값을 살펴봅니다.

    ```json
    "AzureWebJobsStorage": "UseDevelopmentStorage=true",
    ```

1. **AzureWebJobsStorage** 요소의 값을 이 랩의 앞부분에서 기록한 스토리지 계정의  **연결 문자열**로 변경합니다.
1. **Local.settings.json** 파일을 저장합니다.

#### <a name="task-3-build-and-validate-a-project"></a>작업 3: 프로젝트 빌드 및 유효성 검사

1. 작업 표시줄에서 **Windows 터미널** 아이콘을 선택합니다.
1. 다음 명령을 실행하여 현재 디렉터리를 **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** 디렉터리로 변경합니다.

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. 다음 명령을 실행하여 .NET Core 3.1 프로젝트를 **빌드**합니다.

    ```powershell
    dotnet build
    ```

#### <a name="review"></a>검토

이 연습에서는 Azure Functions 개발에 사용할 로컬 프로젝트를 만들었습니다.

### <a name="exercise-3-create-a-function-thats-triggered-by-an-http-request"></a>연습 3: HTTP 요청에 의해 트리거되는 함수 만들기

#### <a name="task-1-create-an-http-triggered-function"></a>작업 1: HTTP 트리거 함수 만들기

1. 작업 표시줄에서 **Windows 터미널** 아이콘을 선택합니다.
1. 다음 명령을 실행하여 현재 디렉터리를 **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** 디렉터리로 변경합니다.

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. 다음 명령을 실행하여 **Azure Functions Core Tools**를 사용하여 **HTTP 트리거** 템플릿으로 **Echo**라는 새 함수를 만듭니다.

    ```powershell
    func new --template "HTTP trigger" --name "Echo"
    ```

    > **참고**: 설명서의 내용을 검토하여 **Azure Functions Core Tools**를 사용한 [새 함수 만들기][azure-functions-core-tools-new-function] 방법을 파악할 수 있습니다.

1. 현재 실행 중인 **Windows 터미널** 애플리케이션을 닫습니다.

#### <a name="task-2-write-http-triggered-function-code"></a>작업 2: HTTP 트리거 함수 코드 작성

1. **시작** 화면에서 **Visual Studio Code** 타일을 선택합니다.
1. **파일** 메뉴에서 **폴더 열기**를 선택합니다.
1. 열리는 **파일 탐색기** 창에서 **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func**을 찾아본 후, **폴더 선택**을 선택합니다.
1. **Visual Studio Code** 창의 **탐색기** 창에서 **Echo.cs** 파일을 엽니다.
1. 코드 편집기에서 예제 구현을 살펴봅니다.

    ```csharp
    using System;
    using System.IO;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.Azure.WebJobs.Extensions.Http;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;
    using Newtonsoft.Json;
    namespace func
    {
        public static class Echo
        {
            [FunctionName("Echo")]
            public static async Task<IActionResult> Run(
                [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)] HttpRequest req,
                ILogger log)
            {
                log.LogInformation("C# HTTP trigger function processed a request.");
                string name = req.Query["name"];
                string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
                dynamic data = JsonConvert.DeserializeObject(requestBody);
                name = name ?? data?.name;
                string responseMessage = string.IsNullOrEmpty(name)
                    ? "This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response."
                    : $"Hello, {name}. This HTTP triggered function executed successfully.";
                return new OkObjectResult(responseMessage);
            }
        }
    }
    ```

1. **Echo.cs** 파일 내의 모든 내용을 삭제합니다.
1. 다음 코드 줄을 추가하여 **Microsoft.AspNetCore.Mvc**, **Microsoft.Azure.WebJobs**, **Microsoft.AspNetCore.Http** 및 **Microsoft.Extensions.Logging** 네임스페이스에 **using 지시문**을 추가합니다.

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;
    ```

1. 새 **public static** 클래스 **Echo**를 만듭니다.

    ```csharp
    public static class Echo
    { }
    ```

1. **Echo.cs** 파일을 다시 살펴봅니다. 이제 파일에 다음 코드가 포함되어 있어야 합니다.

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;
    public static class Echo
    { }
    ```

1. **Echo** 클래스 내에서 다음 코드 블록을 추가하여 새 **public static** 메서드 **Run**을 만듭니다. 이 메서드는 **IActionResult** 유형 변수를 반환하며, **HttpRequest** 및 **ILogger** 유형 변수를 *request* 및 *logger* 매개 변수로 가져옵니다.

    ```csharp
    public static IActionResult Run(
        HttpRequest request,
        ILogger logger)
    { }
    ```

1. 다음 코드를 추가하여 **name** 매개 변수가 **Echo** 값으로 설정된 **FunctionNameAttribute** 유형 특성을 **Run** 메서드에 추가합니다.

    ```csharp
    [FunctionName("Echo")]
    public static IActionResult Run(
        HttpRequest request,
        ILogger logger)
    { }
    ```

1. 다음 코드를 추가하여 **methods** 매개 변수 배열이 단일 값 **POST**로 설정된 **HttpTriggerAttribute** 유형 특성을 **request** 매개 변수에 추가합니다.

    ```csharp
    [FunctionName("Echo")]
    public static IActionResult Run(
        [HttpTrigger("POST")] HttpRequest request,
        ILogger logger)
    { }
    ```

1. **Echo.cs** 파일을 다시 살펴봅니다. 이제 파일에 다음 코드가 포함되어 있어야 합니다.

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;
    public static class Echo
    {
        [FunctionName("Echo")]
        public static IActionResult Run(
            [HttpTrigger("POST")] HttpRequest request,
            ILogger logger)
        { }
    }
    ```

1. **Run** 메서드에서 다음 코드 줄을 입력하여 고정 메시지를 로깅합니다.

    ```csharp
    logger.LogInformation("Received a request");
    ```

1. HTTP 요청의 본문을 HTTP 응답으로 에코하는 다음 코드 줄을 입력합니다.

    ```csharp
    return new OkObjectResult(request.Body);
    ```

1. **Echo.cs** 파일을 다시 살펴봅니다. 이제 파일에 다음 코드가 포함되어 있어야 합니다.

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;
    public static class Echo
    {
        [FunctionName("Echo")]
        public static IActionResult Run(
            [HttpTrigger("POST")] HttpRequest request,
            ILogger logger)
        {
            logger.LogInformation("Received a request");
            return new OkObjectResult(request.Body);
        }
    }
    ```

1. **저장**을 선택하여 **Echo.cs** 파일의 변경 내용을 저장합니다.

#### <a name="task-3-test-the-http-triggered-function-by-using-httprepl"></a>작업 3: httprepl을 사용하여 HTTP 트리거 함수 테스트

1. 작업 표시줄에서 **Windows 터미널** 아이콘을 선택합니다.
1. 다음 명령을 실행하여 현재 디렉터리를 **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** 디렉터리로 변경합니다.

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. 다음 명령을 실행하여 함수 앱 프로젝트를 실행합니다.

    ```powershell
    func start --build
    ```

    > **참고**: 설명서의 내용을 검토하여 **Azure Functions Core Tools**를 사용한 [로컬에서 함수 앱 프로젝트 시작](https://docs.microsoft.com/azure/azure-functions/functions-develop-local) 방법을 파악할 수 있습니다.
    
1. Microsoft는 커뮤니티에서 변경해야 할 사항이 있음을 알려줄 때 이 학습 과정을 업데이트합니다.

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```
    
1. 명령 프롬프트에서 다음 명령을 실행하여 **httprepl** 도구를 설치 및 시작하고 기본 URI(Uniform Resource Identifier)를 ``http://localhost:7071``로 설정합니다.

    ```powershell
    dotnet tool install -g Microsoft.dotnet-httprepl
    httprepl http://localhost:7071
    ```

    > 그러나 클라우드 업데이트가 자주 이루어지기 때문에 이 학습 콘텐츠가 업데이트되기 전에 UI가 변경될 수 있습니다.
1. 도구 프롬프트에서 다음 명령을 실행하고 상대 **api** 디렉터리를 찾습니다.

    ```powershell
    cd api
    ```

1. 다음 명령을 실행하여 상대 **echo** 디렉터리를 찾습니다.

    ```powershell
    cd echo
    ```

1. 다음 명령을 실행하여 **\-\-content** 옵션을 통해 HTTP 요청 본문을 전송하는 **post** 명령을 실행합니다. 요청 본문은 숫자 값이 **3**으로 설정되어 있습니다.

    ```powershell
    post --content 3
    ```

1. 다음 명령을 실행하여 **\-\-content** 옵션을 통해 HTTP 요청 본문을 전송하는 **post** 명령을 실행합니다. 요청 본문은 숫자 값이 **5**로 설정되어 있습니다.

    ```powershell
    post --content 5
    ```

1. 다음 명령을 실행하여 **\-\-content** 옵션을 통해 HTTP 요청 본문을 전송하는 **post** 명령을 실행합니다. 요청 본문은 문자열 값이 **Hello**로 설정되어 있습니다.

    ```powershell
    post --content "Hello"
    ```

1. 다음 명령을 실행하여 **post** 명령을 실행합니다. 이때, HTTP 요청 본문에서 JavaScript Object Notation (JSON) 값을 **{"msg": "Successful"}** 로 설정하고 **\-\-content** 옵션을 사용하여 HTTP 요청 본문을 전송합니다.

    ```powershell
    post --content "{"msg": "Successful"}"
    ```

1. 다음 명령을 실행하여 **httprepl** 애플리케이션을 종료합니다.

    ```powershell
    exit
    ```

1. 현재 실행 중인 **Windows 터미널** 애플리케이션의 모든 인스턴스를 닫습니다.

#### <a name="review"></a>검토

이 연습에서는 HTTP POST 요청을 통해 전송된 콘텐츠를 에코하는 기본 함수를 만들었습니다.

### <a name="exercise-4-create-a-function-that-triggers-on-a-schedule"></a>연습 4: 일정에 따라 트리거하는 함수 만들기

#### <a name="task-1-create-a-schedule-triggered-function"></a>작업 1: 일정에 따라 트리거되는 함수 만들기

1. 작업 표시줄에서 **Windows 터미널** 아이콘을 선택합니다.
1. 다음 명령을 실행하여 현재 디렉터리를 **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** 디렉터리로 변경합니다.

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. 명령 프롬프트에서 다음 명령을 실행하여 **Azure Functions Core Tools**를 사용하여 **타이머 트리거** 템플릿을 통해 **Recurring**이라는 새 함수를 만듭니다.

    ```powershell
    func new --template "Timer trigger" --name "Recurring"
    ```

    > **참고**: 설명서의 내용을 검토하여 **Azure Functions Core Tools**를 사용한 [새 함수 만들기][azure-functions-core-tools-new-function] 방법을 파악할 수 있습니다.
    
1. 현재 실행 중인 **Windows 터미널** 애플리케이션을 닫습니다.

#### <a name="task-2-observe-function-code"></a>작업 2: 함수 코드 관찰

1. **시작** 화면에서 **Visual Studio Code** 타일을 선택합니다.
1. **파일** 메뉴에서 **폴더 열기**를 선택합니다.
1. 열리는 **파일 탐색기** 창에서 **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func**을 찾아본 후, **폴더 선택**을 선택합니다.
1. **Visual Studio Code** 창의 **탐색기** 창에서 **Recurring.cs** 파일을 엽니다.
1. 코드 편집기에서 코드의 구현을 살펴봅니다.

    ```csharp
    using System;
    using Microsoft.Azure.WebJobs;
    using Microsoft.Azure.WebJobs.Host;
    using Microsoft.Extensions.Logging;    
    namespace func
    {
        public static class Recurring
        {
            [FunctionName("Recurring")]
            public static void Run([TimerTrigger("0 */5 * * * *")]TimerInfo myTimer, ILogger log)
            {
                log.LogInformation($"C# Timer trigger function executed at: {DateTime.Now}");
            }
        }
    }
    ```

#### <a name="task-3-observe-function-runs"></a>작업 3: 함수 실행 관찰

1. 작업 표시줄에서 **Windows 터미널** 아이콘을 선택합니다.
1. 다음 명령을 실행하여 현재 디렉터리를 **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** 디렉터리로 변경합니다.

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. 명령 프롬프트에서 다음 명령을 실행하여 함수 앱 프로젝트를 실행합니다.

    ```powershell
    func start --build
    ```

    > **참고**: 설명서의 내용을 검토하여 **Azure Functions Core Tools**를 사용한 [로컬에서 함수 앱 프로젝트 시작][azure-functions-core-tools-start-function] 방법을 파악할 수 있습니다.
1. **이 경우 변경 사항에 적응하고 필요에 따라 랩에서 작업합니다.**
1. 현재 실행 중인 **Windows 터미널** 애플리케이션을 닫습니다.

#### <a name="task-4-update-the-function-integration-configuration"></a>작업 4: 함수 통합 구성 업데이트

1. **시작** 화면에서 **Visual Studio Code** 타일을 선택합니다.
1. **파일** 메뉴에서 **폴더 열기**를 선택합니다.
1. 열리는 **파일 탐색기** 창에서 **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func**을 찾아본 후, **폴더 선택**을 선택합니다.
1. **Visual Studio Code** 창의 **탐색기** 창에서 **Recurring.cs** 파일을 엽니다.
1. 코드 편집기에서 기존 **Run** 메서드 서명을 살펴봅니다.

    ```csharp
    [FunctionName("Recurring")]
    public void Run([TimerTrigger("0 */5 * * * *")]TimerInfo myTimer, ILogger log)
    ```

1. **Run** 메서드 서명 코드 블록을 업데이트하여 **30초**마다 실행되도록 일정을 변경합니다.

    ```csharp
    [FunctionName("Recurring")]
    public void Run([TimerTrigger("*/30 * * * * *")]TimerInfo myTimer, ILogger log)
    ```

1. **저장**을 선택하여 **Recurring.cs** 파일의 변경 내용을 저장합니다.

#### <a name="task-5-observe-function-runs"></a>작업 5: 함수 실행 관찰

1. 작업 표시줄에서 **Windows 터미널** 아이콘을 선택합니다.

1. 다음 명령을 실행하여 현재 디렉터리를 **Allfiles (F):\\Allfiles\\Labs\\02\    \Starter\\func** 디렉터리로 변경합니다.

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. 1. 명령 프롬프트에서 다음 명령을 실행하여 함수 앱 프로젝트를 실행합니다.

    ```powershell
    func start --build
    ```
    
    > **참고**: 설명서의 내용을 검토하여 **Azure Functions Core Tools**를 사용한 [로컬에서 함수 앱 프로젝트 시작][azure-functions-core-tools-start-function] 방법을 파악할 수 있습니다.
    
1. Observe the function run that occurs about every 30 seconds. Each function run should render a simple message to the log.

1. 현재 실행 중인 **Windows 터미널** 애플리케이션을 닫습니다.

1. Visual Studio Code 창을 닫습니다.

#### <a name="review"></a>검토

이 연습에서는 고정된 일정에 따라 자동으로 실행되는 함수를 만들었습니다.

### <a name="exercise-5-create-a-function-that-integrates-with-other-services"></a>연습5: 다른 서비스와 통합되는 함수 만들기

#### <a name="task-1-upload-sample-content-to-azure-blob-storage"></a>작업 1: Azure Blob Storage에 샘플 콘텐츠 업로드

1. Azure Portal의 **탐색** 창에서 **리소스 그룹** 링크를 선택합니다.
1. **리소스 그룹** 창에서 이 랩의 앞부분에서 만든 **Serverless** 리소스 그룹을 선택합니다.
1. **Serverless** 창에서 이 랩의 앞부분에서 만든 **funcstor** _[사용자 이름]_ 스토리지 계정을 선택합니다.
1. **스토리지 계정** 블레이드에서 **데이터 스토리지** 섹션에 있는 **컨테이너** 링크를 선택합니다.
1. **컨테이너** 섹션에서 **+ 컨테이너**를 선택합니다.
1. **새 컨테이너** 팝업 창에서 다음 작업을 수행하고 **만들기**를 선택합니다.

    | 설정 | 작업 |
    | -- | -- |
    | **이름** 텍스트 상자  | **content**를 입력합니다. |
    | **공용 액세스 수준** 드롭다운 목록  | **프라이빗(익명 액세스 없음)** 을 선택합니다. |

1. **컨테이너** 섹션으로 돌아가서 최근에 만든 **content** 컨테이너를 선택합니다.
1. **컨테이너** 블레이드에서 **업로드**를 선택합니다.
1. **Blob 업로드** 창에서 다음 작업을 수행한 다음, **업로드**를 선택합니다.

    | 설정 | 작업 |
    | -- | -- |
    | **파일** 섹션  | **폴더** 아이콘을 선택합니다. |
    | **파일 탐색기** 창  | **Allfiles (F):\\Allfiles\\Labs\\02\\Starter**를 찾아보고 **settings.json** 파일을 선택한 다음 **열기**를 선택합니다. |
    | **파일이 이미 있는 경우 덮어쓰기** 확인란 | 이 확인란이 선택되어 있는지 확인합니다. |

      > **참고**: 이 랩을 계속하기 전에 Blob이 업로드될 때까지 기다립니다.

#### <a name="task-2-create-an-http-triggered-function"></a>작업 2: HTTP 트리거 함수 만들기

1. 작업 표시줄에서 **Windows 터미널** 아이콘을 선택합니다.
1. 다음 명령을 실행하여 현재 디렉터리를 **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** 디렉터리로 변경합니다.

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. 명령 프롬프트에서 다음 명령을 실행하여 **Azure Functions Core Tools**를 사용하여 **HTTP 트리거** 템플릿을 통해 **GetSettingInfo**라는 새 함수를 만듭니다.

    ```powershell
    func new --template "HTTP trigger" --name "GetSettingInfo"
    ```

    > **참고**: 설명서의 내용을 검토하여 **Azure Functions Core Tools**를 사용한 [새 함수 만들기][azure-functions-core-tools-new-function] 방법을 파악할 수 있습니다.
1. 현재 실행 중인 **Windows 터미널** 애플리케이션을 닫습니다.

#### <a name="task-3-write-http-triggered-and-blob-inputted-function-code"></a>작업 3: HTTP에서 트리거되어 Blob에 입력되는 함수 코드 작성

1. **시작** 화면에서 **Visual Studio Code** 타일을 선택합니다.
1. **파일** 메뉴에서 **폴더 열기**를 선택합니다.
1. 열리는 **파일 탐색기** 창에서 **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func**을 찾아본 후, **폴더 선택**을 선택합니다.
1. **Visual Studio Code** 창의 **탐색기** 창에서 **GetSettingInfo.cs** 파일을 엽니다.
1. 코드 편집기에서 예제 구현을 살펴봅니다.

    ```csharp
    using System;
    using System.IO;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.Azure.WebJobs.Extensions.Http;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;
    using Newtonsoft.Json;    
    namespace func
    {
        public static class GetSettingInfo
        {
            [FunctionName("GetSettingInfo")]
            public static async Task<IActionResult> Run(
                [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)] HttpRequest req,
                ILogger log)
            {
                log.LogInformation("C# HTTP trigger function processed a request.");    
                string name = req.Query["name"];    
                string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
                dynamic data = JsonConvert.DeserializeObject(requestBody);
                name = name ?? data?.name;    
                string responseMessage = string.IsNullOrEmpty(name)
                    ? "This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response."
                    : $"Hello, {name}. This HTTP triggered function executed successfully.";    
                return new OkObjectResult(responseMessage);
            }
        }
    }
    ```

1. **GetSettingInfo.cs** 파일 내의 모든 내용을 삭제합니다.

1. 다음 코드 줄을 추가하여 **Microsoft.AspNetCore.Http**, **Microsoft.AspNetCore.Mvc** 및 **Microsoft.Azure.WebJobs** 네임스페이스에 **using 지시문**을 추가합니다.

    ```csharp
    using Microsoft.AspNetCore.Http;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    ```

1. 새 **public static** 클래스 **GetSettingInfo**를 만듭니다.

    ```csharp
    public static class GetSettingInfo
    { }
    ```

1. **GetSettingInfo.cs** 파일을 다시 살펴봅니다. 이제 파일에 다음 코드가 포함되어 있어야 합니다.

    ```csharp
    using Microsoft.AspNetCore.Http;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    public static class GetSettingInfo
    { }
    ```

1. **GetSettingInfo** 클래스 내에서 다음 코드 블록을 추가하여 새 **public static** 식 본문 메서드 **Run**을 만듭니다. 이 메서드는 **IActionResult** 유형 변수를 반환하며, **HttpRequest** 및 **string** 유형 변수를 *request* 및 *json* 매개 변수로 가져옵니다.

    ```csharp
    public static IActionResult Run(
        HttpRequest request,
        string json)
        => null;
    ```

    > **참고**: 여기서는 임시로 반환 값을 **null**로 설정합니다.

1. 다음 코드를 추가하여 **name** 매개 변수가 **GetSettingInfo** 값으로 설정된 **FunctionNameAttribute** 유형 특성을 **Run** 메서드에 추가합니다.

    ```csharp
    [FunctionName("GetSettingInfo")]
    public static IActionResult Run(
        HttpRequest request,
        string json)
        => null;
    ```

1. 다음 코드를 추가하여 **methods** 매개 변수 배열이 단일 값 **GET**으로 설정된 **HttpTriggerAttribute** 유형 특성을 **request** 매개 변수에 추가합니다.

    ```csharp
    [FunctionName("GetSettingInfo")]
    public static IActionResult Run(
        [HttpTrigger("GET")] HttpRequest request,
        string json)
        => null;
    ```

1. 다음 코드를 추가하여 **blobPath** 매개 변수가 **content/settings.json** 값으로 설정된 **BlobAttribute** 유형 특성을 **json** 매개 변수에 추가합니다.

    ```csharp
    [FunctionName("GetSettingInfo")]
    public static IActionResult Run(
        [HttpTrigger("GET")] HttpRequest request,
        [Blob("content/settings.json")] string json)
        => null;
    ```

1. 다음 코드를 추가하여 단일 생성자 매개 변수로 **json** 메서드 매개 변수 값을 전달하면 **OkObjectResult** 클래스의 새 인스턴스가 반환되도록 **Run** 식 본문 메서드를 업데이트합니다.

    ```csharp
    [FunctionName("GetSettingInfo")]
    public static IActionResult Run(
        [HttpTrigger("GET")] HttpRequest request,
        [Blob("content/settings.json")] string json)
        => new OkObjectResult(json);
    ```

1. **GetSettingInfo.cs** 파일을 다시 살펴봅니다. 이제 파일에 다음 코드가 포함되어 있어야 합니다.

    ```csharp
    using Microsoft.AspNetCore.Http;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    public static class GetSettingInfo
    {
        [FunctionName("GetSettingInfo")]
        public static IActionResult Run(
            [HttpTrigger("GET")] HttpRequest request,
            [Blob("content/settings.json")] string json)
            => new OkObjectResult(json);
    }
    ```

1. **저장**을 선택하여 **Recurring.cs** 파일의 변경 내용을 저장합니다.

#### <a name="task-4-register-azure-storage-blob-extensions"></a>작업 4: Azure Storage Blob 확장 등록

1. 작업 표시줄에서 **Windows 터미널** 아이콘을 선택합니다.
1. 다음 명령을 실행하여 현재 디렉터리를 **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** 디렉터리로 변경합니다.

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. 명령 프롬프트에서 다음 명령을 실행하여 [Microsoft.Azure.WebJobs.Extensions.Storage](https://www.nuget.org/packages/Microsoft.Azure.WebJobs.Extensions.Storage/) 확장을 등록합니다.

    ```powershell
    func extensions install --package Microsoft.Azure.WebJobs.Extensions.Storage --version 5.0.1
    ```

1. 다음 명령을 실행하여 .NET 프로젝트를 빌드해 확장이 올바르게 설치되었는지 유효성을 검사합니다.

    ```powershell
    dotnet build
    ```

1. 현재 실행 중인 **Windows 터미널** 애플리케이션의 모든 인스턴스를 닫습니다.

#### <a name="task-5-test-the-function-by-using-httprepl"></a>작업 5: httprepl을 사용하여 함수 테스트

1. 작업 표시줄에서 **Windows 터미널** 아이콘을 선택합니다.
1. 다음 명령을 실행하여 현재 디렉터리를 **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** 디렉터리로 변경합니다.

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. 명령 프롬프트에서 다음 명령을 실행하여 함수 앱 프로젝트를 실행합니다.

    ```powershell
    func start --build
    ```

    > **참고**: 설명서의 내용을 검토하여 **Azure Functions Core Tools**를 사용한 [로컬에서 함수 앱 프로젝트 시작][azure-functions-core-tools-start-function] 방법을 파악할 수 있습니다.
1. 작업 표시줄에서 **Windows 터미널** 아이콘을 다시 선택하여 **Windows 터미널** 애플리케이션의 새 인스턴스를 엽니다.
1. 명령 프롬프트에서 다음 명령을 실행하여 **httprepl** 도구를 시작하고 기본 URI(Uniform Resource Identifier)를 ``http://localhost:7071``로 설정합니다.

    ```powershell
    httprepl http://localhost:7071
    ```

    > <bpt id="p1">**</bpt>Note<ept id="p1">**</ept>: An error message is displayed by the <bpt id="p2">**</bpt>httprepl<ept id="p2">**</ept> tool. This message occurs because the tool is searching for a Swagger definition file to use to traverse the API. Because your function project doesn't produce a Swagger definition file, you'll need to traverse the API manually.

1. 도구 프롬프트가 표시되면 다음 명령을 실행하고 상대 **api** 엔드포인트를 찾습니다.

    ```powershell
    cd api
    ```

1. 다음 명령을 실행하여 상대 **getsettinginfo** 엔드포인트를 찾습니다.

    ```powershell
    cd getsettinginfo
    ```

1. 다음 명령을 실행하여 현재 엔드포인트에 대해 **get** 명령을 실행합니다.

    ```powershell
    get
    ```

1. 함수 앱에서 나온 응답의 JSON 콘텐츠를 살펴봅니다. 여기에는 다음이 포함되어야 합니다.

    ```json
    {
        "version": "0.2.4",
        "root": "/usr/libexec/mews_principal/",
        "device": {
            "id": "21e46d2b2b926cba031a23c6919"
        },
        "notifications": {
            "email": "joseph.price@contoso.com",
            "phone": "(425) 555-0162 x4151"
        }
    }
    ```

1. 다음 명령을 실행하여 **httprepl** 애플리케이션을 종료합니다.

    ```powershell
    exit
    ```

1. 현재 실행 중인 **Windows 터미널** 애플리케이션의 모든 인스턴스를 닫습니다.

#### <a name="review"></a>검토

이 연습에서는 저장소에서 JSON 파일의 콘텐츠를 반환하는 함수를 만들었습니다.

### <a name="exercise-6-deploy-a-local-function-project-to-an-azure-functions-app"></a>연습 6: Azure Functions 앱에 로컬 함수 프로젝트 배포

#### <a name="task-1-deploy-using-the-azure-functions-core-tools"></a>작업 1: Azure Functions Core Tools를 사용하여 배포

1. 작업 표시줄에서 **Windows 터미널** 아이콘을 선택합니다.
1. 다음 명령을 실행하여 현재 디렉터리를 **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** 디렉터리로 변경합니다.

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. 명령 프롬프트에서 다음 명령을 실행하여 Azure CLI(명령줄 인터페이스)에 로그인합니다.

    ```powershell
    az login
    ```

1. **Microsoft Edge** 브라우저 창에서 이 랩에서 사용 중인 Microsoft 또는 Azure Active Directory 계정의 이름 및 암호를 입력한 다음, **로그인**을 선택합니다.
1. Return to the currently open <bpt id="p1">**</bpt>Windows Terminal<ept id="p1">**</ept> window. Wait for the sign-in process to finish.
1. 명령 프롬프트에서 다음 명령을 실행하여 함수 앱 프로젝트를 게시합니다(`<function-app-name>` 자리 표시자를 이 랩의 앞부분에서 만든 함수 앱의 이름으로 바꿈).

    ```powershell
    func azure functionapp publish <function-app-name>
    ```

    > <bpt id="p1">**</bpt>Note<ept id="p1">**</ept>: For example, if your <bpt id="p2">**</bpt>Function App name<ept id="p2">**</ept> is <bpt id="p3">**</bpt>funclogicstudent<ept id="p3">**</ept>, your command would be <ph id="ph1">``func azure functionapp publish funclogicstudent``</ph>. You can review the documentation to [publish the local function app project][azure-functions-core-tools-publish-azure] using the <bpt id="p1">**</bpt>Azure Functions Core Tools<ept id="p1">**</ept>.

1. 랩을 진행하기 전에 배포가 마무리될 때까지 기다립니다.
1. 현재 실행 중인 **Windows 터미널** 애플리케이션을 닫습니다.

#### <a name="task-2-validate-deployment"></a>작업 2: 배포 유효성 검사

1. 작업 표시줄에서 **Microsoft Edge** 아이콘을 선택하고, Azure Portal(<https://portal.azure.com>)이 표시된 탭을 선택합니다.
1. Azure Portal의 **탐색** 창에서 **리소스 그룹** 링크를 선택합니다.
1. **리소스 그룹** 창에서 이 랩의 앞부분에서 만든 **Serverless** 리소스 그룹을 선택합니다.
1. **Serverless** 창에서 이 랩의 앞부분에서 만든 **funclogic** _[사용자 정의]_ 함수 앱을 선택합니다.
1. **함수 앱** 창의 **함수** 섹션에서 **함수** 옵션을 선택합니다.
1. **Functions** 창에서 기존 **GetSettingInfo** 함수를 선택합니다.
1. **함수** 창의 **개발자** 섹션에서 **코드 + 테스트** 옵션을 선택합니다.
1. 함수 편집기에서 **테스트/실행을** 선택합니다.
1. 자동으로 표시되는 창의 **HTTP 메서드** 드롭다운 목록에서 **GET**을 선택합니다.
1. **실행**을 선택하여 함수를 테스트합니다.
1. In the <bpt id="p1">**</bpt>HTTP response content<ept id="p1">**</ept>, review the results of the test run. The JSON content should now include the following code:

    ```json
    {
        "version": "0.2.4",
        "root": "/usr/libexec/mews_principal/",
        "device": {
            "id": "21e46d2b2b926cba031a23c6919"
        },
        "notifications": {
            "email": "joseph.price@contoso.com",
            "phone": "(425) 555-0162 x4151"
        }
    }
    ```

#### <a name="review"></a>검토

이 연습에서는 Azure Functions에 로컬 함수 프로젝트를 배포했으며 함수가 Azure에서 작동하는지 유효성을 검사했습니다.

### <a name="exercise-7-clean-up-your-subscription"></a>연습 7: 구독 정리

#### <a name="task-1-open-azure-cloud-shell-and-list-resource-groups"></a>작업 1: Azure Cloud Shell 열기 및 리소스 그룹 나열

1.  In the Azure portal, select the <bpt id="p1">**</bpt>Cloud Shell<ept id="p1">**</ept> icon <ph id="ph1">![</ph>Cloud Shell icon<ph id="ph2">](./media/az204_lab_CloudShell.png)</ph> to open a new Bash session. If Cloud Shell defaults to a PowerShell session, select <bpt id="p1">**</bpt>PowerShell<ept id="p1">**</ept>, and in the drop-down menu, select <bpt id="p2">**</bpt>Bash<ept id="p2">**</ept>.

    > <bpt id="p1">**</bpt>Note<ept id="p1">**</ept>: If this is the first time you're starting <bpt id="p2">**</bpt>Cloud Shell<ept id="p2">**</ept>, when prompted to select either <bpt id="p3">**</bpt>Bash<ept id="p3">**</ept> or <bpt id="p4">**</bpt>PowerShell<ept id="p4">**</ept>, select <bpt id="p5">**</bpt>PowerShell<ept id="p5">**</ept>. When you're presented with the <bpt id="p1">**</bpt>You have no storage mounted<ept id="p1">**</ept> message, select the subscription you're using in this lab, and then select <bpt id="p2">**</bpt>Create storage<ept id="p2">**</ept>.

#### <a name="task-2-delete-a-resource-group"></a>작업 2: 리소스 그룹 삭제

1. **Cloud Shell** 창에서 다음 명령을 실행하여 **Serverless** 리소스 그룹을 삭제합니다.

    ```powershell
    az group delete --name Serverless --no-wait --yes
    ```
     > **참고**: 이 명령은 *--no-wait* 매개 변수에서 알 수 있듯이 비동기로 실행되므로, 동일한 Bash 세션 내에서 이 명령을 실행한 직후에 다른 Azure CLI 명령을 실행하는 것이 가능하지만 리소스 그룹이 제거되기까지는 몇 분 정도 걸립니다.

1. 포털에서 **Cloud Shell** 창을 닫습니다.

#### <a name="task-3-close-the-active-application"></a>작업 3: 활성 애플리케이션 닫기

- 현재 실행 중인 Microsoft Edge 애플리케이션을 닫습니다.

#### <a name="review"></a>검토

이 연습에서는이 랩에 사용된 리소스 그룹을 제거하여 구독을 정리했습니다.
